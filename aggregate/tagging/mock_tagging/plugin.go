// Code generated by MockGen. DO NOT EDIT.
// Source: plugin.go

// Package mock_tagging is a generated GoMock package.
package mock_tagging

import (
	context "context"
	reflect "reflect"

	gomock "github.com/golang/mock/gomock"
	uuid "github.com/google/uuid"
	tagging "github.com/modernice/goes/aggregate/tagging"
)

// MockStore is a mock of Store interface.
type MockStore struct {
	ctrl     *gomock.Controller
	recorder *MockStoreMockRecorder
}

// MockStoreMockRecorder is the mock recorder for MockStore.
type MockStoreMockRecorder struct {
	mock *MockStore
}

// NewMockStore creates a new mock instance.
func NewMockStore(ctrl *gomock.Controller) *MockStore {
	mock := &MockStore{ctrl: ctrl}
	mock.recorder = &MockStoreMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockStore) EXPECT() *MockStoreMockRecorder {
	return m.recorder
}

// TaggedWith mocks base method.
func (m *MockStore) TaggedWith(arg0 context.Context, arg1 ...string) ([]tagging.Aggregate, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0}
	for _, a := range arg1 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "TaggedWith", varargs...)
	ret0, _ := ret[0].([]tagging.Aggregate)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// TaggedWith indicates an expected call of TaggedWith.
func (mr *MockStoreMockRecorder) TaggedWith(arg0 interface{}, arg1 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0}, arg1...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TaggedWith", reflect.TypeOf((*MockStore)(nil).TaggedWith), varargs...)
}

// Tags mocks base method.
func (m *MockStore) Tags(arg0 context.Context, arg1 string, arg2 uuid.UUID) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Tags", arg0, arg1, arg2)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Tags indicates an expected call of Tags.
func (mr *MockStoreMockRecorder) Tags(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Tags", reflect.TypeOf((*MockStore)(nil).Tags), arg0, arg1, arg2)
}

// Update mocks base method.
func (m *MockStore) Update(arg0 context.Context, aggregateName string, aggregateID uuid.UUID, tags []string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Update", arg0, aggregateName, aggregateID, tags)
	ret0, _ := ret[0].(error)
	return ret0
}

// Update indicates an expected call of Update.
func (mr *MockStoreMockRecorder) Update(arg0, aggregateName, aggregateID, tags interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockStore)(nil).Update), arg0, aggregateName, aggregateID, tags)
}

// Mocktagger is a mock of tagger interface.
type Mocktagger struct {
	ctrl     *gomock.Controller
	recorder *MocktaggerMockRecorder
}

// MocktaggerMockRecorder is the mock recorder for Mocktagger.
type MocktaggerMockRecorder struct {
	mock *Mocktagger
}

// NewMocktagger creates a new mock instance.
func NewMocktagger(ctrl *gomock.Controller) *Mocktagger {
	mock := &Mocktagger{ctrl: ctrl}
	mock.recorder = &MocktaggerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *Mocktagger) EXPECT() *MocktaggerMockRecorder {
	return m.recorder
}

// Tags mocks base method.
func (m *Mocktagger) Tags() []string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Tags")
	ret0, _ := ret[0].([]string)
	return ret0
}

// Tags indicates an expected call of Tags.
func (mr *MocktaggerMockRecorder) Tags() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Tags", reflect.TypeOf((*Mocktagger)(nil).Tags))
}
